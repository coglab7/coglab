{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"[ On | No ] syntactic support for error handling","url":"https://go.dev/blog/error-syntax","date":1748908800,"author":"Robert Griesemer","guid":171,"unread":true,"content":"<p>\n      Robert Griesemer\n      3 June 2025\n      </p><p>One of the oldest and most persistent complaints about Go concerns the verbosity of error handling.\nWe are all intimately (some may say painfully) familiar with this code pattern:</p><pre><code>x, err := call()\nif err != nil {\n        // handle err\n}\n</code></pre><p>The test  can be so pervasive that it drowns out the rest of the code.\nThis typically happens in programs that do a lot of API calls, and where handling errors\nis rudimentary and they are simply returned.\nSome programs end up with code that looks like this:</p><pre><code>func printSum(a, b string) error {\n    x, err := strconv.Atoi(a)\n    if err != nil {\n        return err\n    }\n    y, err := strconv.Atoi(b)\n    if err != nil {\n        return err\n    }\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>Of the ten lines of code in this function body, only four (the calls and the last two lines) appear to do real work.\nThe remaining six lines come across as noise.\nThe verbosity is real, and so it’s no wonder that complaints about error handling have topped\nour annual user surveys for years.\n(For a while, the lack of generics surpassed complaints about error handling, but now that\nGo supports generics, error handling is back on top.)</p><p>The Go team takes community feedback seriously, and so for many years now we have tried to\ncome up with a solution for this problem, together with input from the Go community.</p><p>The first explicit attempt by the Go team dates back to 2018, when Russ Cox\n<a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md\" rel=\"noreferrer\" target=\"_blank\">formally described the problem</a>\nas part of what we called the Go 2 effort at that time.\nHe outlined a possible solution based on a\n<a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md\" rel=\"noreferrer\" target=\"_blank\">draft design</a>\nby Marcel van Lohuizen.\nThe design was based on a  and  mechanism and was fairly comprehensive.\nThe draft includes a detailed analysis of alternative solutions, including comparisons with\napproaches taken by other languages.\nIf you’re wondering if your particular error handling idea was previously considered,\nread this document!</p><pre><code>// printSum implementation using the proposed check/handle mechanism.\nfunc printSum(a, b string) error {\n    handle err { return err }\n    x := check strconv.Atoi(a)\n    y := check strconv.Atoi(b)\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>The  and  approach was deemed too complicated and almost a year later, in 2019,\nwe followed up with the much simplified and by now\n<a href=\"https://go.dev/issue/32437#issuecomment-2278932700\">infamous</a><a href=\"https://go.googlesource.com/proposal/+/master/design/32437-try-builtin.md\" rel=\"noreferrer\" target=\"_blank\"> proposal</a>.\nIt was based on the ideas of  and , but the  pseudo-keyword became\nthe  built-in function and the  part was omitted.\nTo explore the impact of the  built-in, we wrote a simple tool\n(<a href=\"https://github.com/griesemer/tryhard\" rel=\"noreferrer\" target=\"_blank\">tryhard</a>)\nthat rewrites existing error handling code using .\nThe proposal was argued over intensively, approaching 900 comments on the <a href=\"https://go.dev/issue/32437\">GitHub issue</a>.</p><pre><code>// printSum implementation using the proposed try mechanism.\nfunc printSum(a, b string) error {\n    // use a defer statement to augment errors before returning\n    x := try(strconv.Atoi(a))\n    y := try(strconv.Atoi(b))\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>However,  affected control flow by returning from the enclosing function in case of an error,\nand did so from potentially deeply nested expressions, thus hiding this control flow from view.\nThis made the proposal unpalatable to many, and despite significant investment\ninto this proposal we decided to abandon this effort too.\nIn retrospect it might have been better to introduce a new keyword,\nsomething that we could do now since we have fine-grained control over the language version\nvia  files and file-specific directives.\nRestricting the use of  to assignments and statements might have alleviated some\nof the other concerns. A <a href=\"https://go.dev/issue/73376\">recent proposal</a> by Jimmy Frasche, which essentially\ngoes back to the original  and  design and addresses some of that design’s\nshortcomings, pursues that direction.</p><p>The repercussions of the  proposal led to much soul searching including a series of blog\nposts by Russ Cox: <a href=\"https://research.swtch.com/proposals-intro\" rel=\"noreferrer\" target=\"_blank\">“Thinking about the Go Proposal Process”</a>.\nOne conclusion was that we likely diminished our chances for a better outcome by presenting an almost\nfully baked proposal with little space for community feedback and a “threatening” implementation\ntimeline. Per <a href=\"https://research.swtch.com/proposals-large\" rel=\"noreferrer\" target=\"_blank\">“Go Proposal Process: Large Changes”</a>:\n“in retrospect,  was a large enough change that the new design we published […] should have\nbeen a second draft design, not a proposal with an implementation timeline”.\nBut irrespective of a possible process and communication failure in this case, the user sentiment towards\nthe proposal was very strongly not in favor.</p><p>We didn’t have a better solution at that time and didn’t pursue syntax changes for error handling for several years.\nPlenty of people in the community were inspired, though, and we received a steady trickle\nof error handling proposals, many very similar to each other, some interesting, some incomprehensible,\nand some infeasible.\nTo keep track of the expanding landscape, another year later, Ian Lance Taylor created an\n<a href=\"https://go.dev/issue/40432\">umbrella issue</a>\nwhich summarizes the current state of proposed changes for improved error handling.\nA <a href=\"https://go.dev/wiki/Go2ErrorHandlingFeedback\">Go Wiki</a> was created to collect related feedback, discussions, and articles.\nIndependently, other people have started tracking all the many error handling proposals\nover the years.\nIt’s amazing to see the sheer volume of them all, for instance in Sean K. H. Liao’s blog post on\n<a href=\"https://seankhliao.com/blog/12020-11-23-go-error-handling-proposals/\" rel=\"noreferrer\" target=\"_blank\">“go error handling proposals”</a>.</p><p>The complaints about the verbosity of error handling persisted\n(see <a href=\"https://go.dev/blog/survey2024-h1-results\">Go Developer Survey 2024 H1 Results</a>),\nand so, after a series of increasingly refined Go team internal proposals, Ian Lance Taylor published\n<a href=\"https://go.dev/issue/71203\">“reduce error handling boilerplate using ”</a> in 2024.\nThis time the idea was to borrow from a construct implemented in\n<a href=\"https://www.rust-lang.org/\" rel=\"noreferrer\" target=\"_blank\">Rust</a>, specifically the\n<a href=\"https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-\" rel=\"noreferrer\" target=\"_blank\"> operator</a>.\nThe hope was that by leaning on an existing mechanism using an established notation, and taking into\naccount what we had learned over the years, we should be able to finally make some progress.\nIn small informal user studies where programmers were shown Go code using , the vast majority\nof participants correctly guessed the meaning of the code, which further convinced us to give it another\nshot.\nTo be able to see the impact of the change, Ian wrote a tool that converts ordinary Go code\ninto code that uses the proposed new syntax, and we also prototyped the feature in the\ncompiler.</p><pre><code>// printSum implementation using the proposed \"?\" statements.\nfunc printSum(a, b string) error {\n    x := strconv.Atoi(a) ?\n    y := strconv.Atoi(b) ?\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre><p>Unfortunately, as with the other error handling ideas, this new proposal was also quickly overrun\nwith comments and many suggestions for minor tweaks, often based on individual preferences.\nIan closed the proposal and moved the content into a <a href=\"https://go.dev/issue/71460\">discussion</a>\nto facilitate the conversation and to collect further feedback.\nA slightly modified version was received\n<a href=\"https://github.com/golang/go/discussions/71460#discussioncomment-12060294\" rel=\"noreferrer\" target=\"_blank\">a bit more positively</a>\nbut broad support remained elusive.</p><p>After so many years of trying, with three full-fledged proposals by the Go team and\nliterally <a href=\"https://go.dev/issues?q=+is%3Aissue+label%3Aerror-handling\">hundreds</a> (!)\nof community proposals, most of them variations on a theme,\nall of which failed to attract sufficient (let alone overwhelming) support,\nthe question we now face is: how to proceed? Should we proceed at all?</p><p>To be more precise, we should stop trying to solve the , at least for the foreseeable\nfuture.\nThe <a href=\"https://github.com/golang/proposal?tab=readme-ov-file#consensus-and-disagreement\" rel=\"noreferrer\" target=\"_blank\">proposal process</a>\nprovides justification for this decision:</p><blockquote><p>The goal of the proposal process is to reach general consensus about the outcome in a timely manner.\nIf proposal review cannot identify a general consensus in the discussion of the issue on the issue tracker,\nthe usual result is that the proposal is declined.</p></blockquote><blockquote><p>It can happen that proposal review may not identify a general consensus and yet it is clear that the\nproposal should not be outright declined.\n[…]\nIf the proposal review group cannot identify a consensus nor a next step for the proposal,\nthe decision about the path forward passes to the Go architects […], who review the discussion and\naim to reach a consensus among themselves.</p></blockquote><p>None of the error handling proposals reached anything close to a consensus,\nso they were all declined.\nEven the most senior members of the Go team at Google do not unanimously agree\non the best path forward  (perhaps that will change at some point).\nBut without a strong consensus we cannot reasonably move forward.</p><p>There are valid arguments in favor of the status quo:</p><ul><li><p>If Go had introduced specific syntactic sugar for error handling early on, few would argue over it today.\nBut we are 15 years down the road, the opportunity has passed, and Go has\na perfectly fine way to handle errors, even if it may seem verbose at times.</p></li><li><p>Looking from a different angle, let’s assume we came across the perfect solution today.\nIncorporating it into the language would simply lead from one unhappy group of users\n(the one that roots for the change) to another (the one that prefers the status quo).\nWe were in a similar situation when we decided to add generics to the language, albeit with an\nimportant difference:\ntoday nobody is forced to use generics, and good generic libraries are written such that users\ncan mostly ignore the fact that they are generic, thanks to type inference.\nOn the contrary, if a new syntactic construct for error handling gets added to the language,\nvirtually everybody will need to start using it, lest their code become unidiomatic.</p></li><li><p>Not adding extra syntax is in line with one of Go’s design rules:\ndo not provide multiple ways of doing the same thing.\nThere are exceptions to this rule in areas with high “foot traffic”: assignments come to mind.\nIronically, the ability to  a variable in\n<a href=\"https://go.dev/ref/spec#Short_variable_declarations\">short variable declarations</a> () was introduced to address a problem\nthat arose because of error handling:\nwithout redeclarations, sequences of error checks require a differently named  variable for\neach check (or additional separate variable declarations).\nAt that time, a better solution might have been to provide more syntactic support for error handling.\nThen, the redeclaration rule may not have been needed, and with it gone, so would be various\nassociated <a href=\"https://go.dev/issue/377\">complications</a>.</p></li><li><p>Going back to actual error handling code, verbosity fades into the background if errors are\nactually .\nGood error handling often requires additional information added to an error.\nFor instance, a recurring comment in user surveys is about the lack of stack traces associated\nwith an error.\nThis could be addressed with support functions that produce and return an augmented\nerror.\nIn this (admittedly contrived) example, the relative amount of boilerplate is much smaller:</p><pre><code>func printSum(a, b string) error {\n    x, err := strconv.Atoi(a)\n    if err != nil {\n        return fmt.Errorf(\"invalid integer: %q\", a)\n    }\n    y, err := strconv.Atoi(b)\n    if err != nil {\n        return fmt.Errorf(\"invalid integer: %q\", b)\n    }\n    fmt.Println(\"result:\", x + y)\n    return nil\n}\n</code></pre></li><li><p>New standard library functionality can help reduce error handling boilerplate as well,\nvery much in the vein of Rob Pike’s 2015 blog post\n<a href=\"https://go.dev/blog/errors-are-values\">“Errors are values”</a>.\nFor instance, in some cases <a href=\"https://go.dev/pkg/cmp#Or\"></a> may be used to deal with a\nseries of errors all at once:</p><pre><code>func printSum(a, b string) error {\n    x, err1 := strconv.Atoi(a)\n    y, err2 := strconv.Atoi(b)\n    if err := cmp.Or(err1, err2); err != nil {\n        return err\n    }\n    fmt.Println(\"result:\", x+y)\n    return nil\n}\n</code></pre></li><li><p>Writing, reading, and debugging code are all quite different activities.\nWriting repeated error checks can be tedious, but today’s IDEs provide powerful, even LLM-assisted\ncode completion.\nWriting basic error checks is straightforward for these tools.\nThe verbosity is most obvious when reading code, but tools might help here as well;\nfor instance an IDE with a Go language setting could provide a toggle switch to hide error handling\ncode.\nSuch switches already exist for other code sections such as function bodies.</p></li><li><p>When debugging error handling code, being able to quickly add a  or\nhave a dedicated line or source location for setting a breakpoint in a debugger is helpful.\nThis is easy when there is already a dedicated  statement.\nBut if all the error handling logic is hidden behind a , , or , the code may have to\nbe changed into an ordinary  statement first, which complicates debugging\nand may even introduce subtle bugs.</p></li><li><p>There are also practical considerations:\nComing up with a new syntax idea for error handling is cheap;\nhence the proliferation of a multitude of proposals from the community.\nComing up with a good solution that holds up to scrutiny: not so much.\nIt takes a concerted effort to properly design a language change and to actually implement it.\nThe real cost still comes afterwards:\nall the code that needs to be changed, the documentation that needs to be updated,\nthe tools that need to be adjusted.\nTaken all into account, language changes are very expensive, the Go team is relatively small,\nand there are a lot of other priorities to address.\n(These latter points may change: priorities can shift, team sizes can go up or down.)</p></li><li><p>On a final note, some of us recently had the opportunity to attend\n<a href=\"https://cloud.withgoogle.com/next/25\" rel=\"noreferrer\" target=\"_blank\">Google Cloud Next 2025</a>,\nwhere the Go team had a booth and where we also hosted a small Go Meetup.\nEvery single Go user we had a chance to ask was adamant that we should not change the\nlanguage for better error handling.\nMany mentioned that the lack of specific error handling support in Go is most apparent\nwhen coming freshly from another language that has that support.\nAs one becomes more fluent and writes more idiomatic Go code, the issue becomes much less important.\nThis is of course not a sufficiently large set of people to be representative,\nbut it may be a different set of people than we see on GitHub, and their feedback serves as yet another data point.</p></li></ul><p>Of course, there are also valid arguments in favor of change:</p><ul><li><p>Lack of better error handling support remains the top complaint in our user surveys.\nIf the Go team really does take user feedback seriously, we ought to do something about this eventually.\n(Although there does not seem to be\n<a href=\"https://github.com/golang/go/discussions/71460#discussioncomment-11977299\" rel=\"noreferrer\" target=\"_blank\">overwhelming support</a>\nfor a language change either.)</p></li><li><p>Perhaps the singular focus on reducing the character count is misguided.\nA better approach might be to make default error handling highly visible with a keyword\nwhile still removing boilerplate ().\nSuch an approach might make it easier for a reader (a code reviewer!) to see that an error\nis handled, without “looking twice”, resulting in improved code quality and safety.\nThis would bring us back to the beginnings of  and .</p></li><li><p>We don’t really know how much the issue is the straightforward syntactic verbosity of\nerror checking, versus the verbosity of good error handling:\nconstructing errors that are a useful part of an API and meaningful to developers and\nend-users alike.\nThis is something we’d like to study in greater depth.</p></li></ul><p>Still, no attempt to address error handling so far has gained sufficient traction.\nIf we are honestly taking stock of where we are, we can only admit that we\nneither have a shared understanding of the problem,\nnor do we all agree that there is a problem in the first place.\nWith this in mind, we are making the following pragmatic decision:</p><p><em>For the foreseeable future, the Go team will stop pursuing syntactic language changes\nfor error handling.\nWe will also close all open and incoming proposals that concern themselves primarily\nwith the syntax of error handling, without further investigation.</em></p><p>The community has put tremendous effort into exploring, discussing, and debating these issues.\nWhile this may not have resulted in any changes to error handling syntax, these efforts have\nresulted in many other improvements to the Go language and our processes.\nMaybe, at some point in the future, a clearer picture will emerge on error handling.\nUntil then, we look forward to focusing this incredible passion on new opportunities\nto make Go better for everyone.</p>","contentLength":15857,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go Cryptography Security Audit","url":"https://go.dev/blog/tob-crypto-audit","date":1747612800,"author":"Roland Shoemaker and Filippo Valsorda","guid":170,"unread":true,"content":"<p>\n      Roland Shoemaker and Filippo Valsorda\n      19 May 2025\n      </p><p>Go ships with a full suite of cryptography packages in the standard library to help developers build secure applications. Google recently contracted the independent security firm <a href=\"https://www.trailofbits.com/\" rel=\"noreferrer\" target=\"_blank\">Trail of Bits</a> to complete an audit of the core set of packages that are also validated as part of the <a href=\"https://go.dev/doc/go1.24#fips140\">new native FIPS 140-3 module</a>. The audit produced a single low-severity finding, in the legacy and unsupported <a href=\"https://go.dev/doc/security/fips140#goboringcrypto\">Go+BoringCrypto integration</a>, and a handful of informational findings. The full text of the audit report can be found <a href=\"https://github.com/trailofbits/publications/blob/d47e8fafa7e3323e5620d228f2f3f3bf58ed5978/reviews/2025-03-google-gocryptographiclibraries-securityreview.pdf\" rel=\"noreferrer\" target=\"_blank\">here</a>.</p><p>The scope of the audit included our implementations of key exchange (ECDH and post-quantum ML-KEM), digital signature (ECDSA, RSA, and Ed25519), encryption (AES-GCM, AES-CBC, and AES-CTR), hashing (SHA-1, SHA-2, and SHA-3), key derivation (HKDF and PBKDF2), and authentication (HMAC), as well as the cryptographic random number generator. Low-level big integer and elliptic curve implementations, with their delicate assembly cores, were included. Higher level protocols like TLS and X.509 were not in scope. Three Trail of Bits engineers worked on the audit for a month.</p><p>We are proud of the security track record of the Go cryptography packages, and of the outcome of this audit, which is just one of many ways we gain assurance of the packages’ correctness. First, we aggressively limit their complexity, guided by the <a href=\"https://go.dev/design/cryptography-principles\">Cryptography Principles</a> which for example prioritize security over performance. Further, we <a href=\"https://www.youtube.com/watch?v=lkEH3V3PkS0\" rel=\"noreferrer\" target=\"_blank\">thoroughly test them</a> with an array of different techniques. We make a point of leveraging safe APIs even for internal packages, and naturally we can rely on the Go language properties to avoid memory management issues. Finally, we focus on readability to make maintenance easier and code review and audits more effective.</p><p>The only potentially exploitable issue, TOB-GOCL-3, has , meaning it had minor impact and was difficult to trigger. This issue has been fixed in Go 1.24.</p><p>The remaining findings are , meaning they do not pose an immediate risk but are relevant to security best practices. We addressed these in the current Go 1.25 development tree.</p><p>Findings TOB-GOCL-1, TOB-GOCL-2, and TOB-GOCL-6 concern possible timing side-channels in various cryptographic operations. Of these three findings, only TOB-GOCL-2 affects operations that were expected to be constant time due to operating on secret values, but it only affects Power ISA targets (GOARCH ppc64 and ppc64le). TOB-GOCL-4 highlights misuse risk in an internal API, should it be repurposed beyond its current use case. TOB-GOCL-5 points out a missing check for a limit that is impractical to reach.</p><p>Findings TOB-GOCL-1, TOB-GOCL-2, and TOB-GOCL-6 concern minor timing side-channels. TOB-GOCL-1 and TOB-GOCL-6 are related to functions which we do not use for sensitive values, but could be used for such values in the future, and TOB-GOCL-2 is related to the assembly implementation of P-256 ECDSA on Power ISA.</p><h3>: conversion from bytes to field elements is not constant time (TOB-GOCL-1)</h3><p>The internal implementation of NIST elliptic curves provided a method to convert field elements between an internal and external representation which operated in variable time.</p><p>All usages of this method operated on public inputs which are not considered secret (public ECDH values, and ECDSA public keys), so we determined that this was not a security issue. That said, we decided to <a href=\"https://go.dev/cl/650579\">make the method constant time anyway</a>, in order to prevent accidentally using this method in the future with secret values, and so that we don’t have to think about whether it is an issue or not.</p><h3>: P-256 conditional negation is not constant time in Power ISA assembly (TOB-GOCL-2, CVE-2025-22866)</h3><p>Beyond the <a href=\"https://go.dev/wiki/PortingPolicy#first-class-ports\">first class Go platforms</a>, Go also supports a number of additional platforms, including some less common architectures. During the review of our assembly implementations of various underlying cryptographic primitives, the Trail of Bits team found one issue that affected the ECDSA implementation on the ppc64 and ppc64le architectures.</p><p>Due to the usage of a conditional branching instruction in the implementation of the conditional negation of P-256 points, the function operated in variable-time, rather than constant-time, as expected. The fix for this was relatively simple, <a href=\"https://go.dev/cl/643735\">replacing the conditional branching instruction</a> with a pattern we already use elsewhere to conditionally select the correct result in constant time. We assigned this issue CVE-2025-22866.</p><p>To prioritize the code that reaches most of our users, and due to the specialized knowledge required to target specific ISAs, we generally rely on community contributions to maintain assembly for non-first class platforms. We thank our partners at IBM for helping provide review for our fix.</p><h3>: Scalar.SetCanonicalBytes is not constant time (TOB-GOCL-6)</h3><p>The internal edwards25519 package provided a method to convert between an internal and external representation of scalars which operated in variable time.</p><p>This method was only used on signature inputs to ed25519.Verify, which are not considered secret, so we determined that this was not a security issue. That said, similarly to the TOB-GOCL-1 finding, we decided to <a href=\"https://go.dev/cl/648035\">make the method constant time anyway</a>, in order to prevent accidentally using this method in the future with secret values, and because we are aware that people fork this code outside of the standard library, and may be using it with secret values.</p><p>Finding TOB-GOCL-3 concerns a memory management issue in the Go+BoringCrypto integration.</p><h3>: custom finalizer may free memory at the start of a C function call using this memory (TOB-GOCL-3)</h3><p>During the review, there were a number of questions about our cgo-based Go+BoringCrypto integration, which provides a FIPS 140-2 compliant cryptography mode for internal usage at Google. The Go+BoringCrypto code is not supported by the Go team for external use, but has been critical for Google’s internal usage of Go.</p><p>The Trail of Bits team found one vulnerability and one <a href=\"https://go.dev/cl/644120\">non-security relevant bug</a>, both of which were results of the manual memory management required to interact with a C library. Since the Go team does not support usage of this code outside of Google, we have chosen not to issue a CVE or Go vulnerability database entry for this issue, but we <a href=\"https://go.dev/cl/644119\">fixed it in Go 1.24</a>.</p><p>This kind of pitfall is one of the many reasons that we decided to move away from the Go+BoringCrypto integration. We have been working on a <a href=\"https://go.dev/doc/security/fips140\">native FIPS 140-3 mode</a> that uses the regular pure Go cryptography packages, allowing us to avoid the complex cgo semantics in favor of the traditional Go memory model.</p><p>Findings TOB-GOCL-4 and TOB-GOCL-5 concern limited implementations of two specifications, <a href=\"https://csrc.nist.gov/pubs/sp/800/90/a/r1/final\" rel=\"noreferrer\" target=\"_blank\">NIST SP 800-90A</a> and <a href=\"https://datatracker.ietf.org/doc/html/rfc8018\" rel=\"noreferrer\" target=\"_blank\">RFC 8018</a>.</p><h3><code>crypto/internal/fips140/drbg</code>: CTR_DRBG API presents multiple misuse risks (TOB-GOCL-4)</h3><p>As part of the <a href=\"https://go.dev/doc/security/fips140\">native FIPS 140-3 mode</a> that we are introducing, we needed an implementation of the NIST CTR_DRBG (an AES-CTR based deterministic random bit generator) to provide compliant randomness.</p><p>Since we only need a small subset of the functionality of the NIST SP 800-90A Rev. 1 CTR_DRBG for our purposes, we did not implement the full specification, in particular omitting the derivation function and personalization strings. These features can be critical to safely use the DRBG in generic contexts.</p><p>As our implementation is tightly scoped to the specific use case we need, and since the implementation is not publicly exported, we determined that this was acceptable and worth the decreased complexity of the implementation. We do not expect this implementation to ever be used for other purposes internally, and have <a href=\"https://go.dev/cl/647815\">added a warning to the documentation</a> that details these limitations.</p><h3>: PBKDF2 does not enforce output length limitations (TOB-GOCL-5)</h3><p>In Go 1.24, we began the process of moving packages from <a href=\"https://golang.org/x/crypto\" rel=\"noreferrer\" target=\"_blank\">golang.org/x/crypto</a> into the standard library, ending a confusing pattern where first-party, high-quality, and stable Go cryptography packages were kept outside of the standard library for no particular reason.</p><p>As part of this process we moved the <a href=\"https://golang.org/x/crypto/pbkdf2\" rel=\"noreferrer\" target=\"_blank\">golang.org/x/crypto/pbkdf2</a> package into the standard library, as crypto/pbkdf2. While reviewing this package, the Trail of Bits team noticed that we did not enforce the limit on the size of derived keys defined in <a href=\"https://datatracker.ietf.org/doc/html/rfc8018\" rel=\"noreferrer\" target=\"_blank\">RFC 8018</a>.</p><p>The limit is <code>(2^32 - 1) * &lt;hash length&gt;</code>, after which the key would loop. When using SHA-256, exceeding the limit would take a key of more than 137GB. We do not expect anyone has ever used PBKDF2 to generate a key this large, especially because PBKDF2 runs the iterations at every block, but for the sake of correctness, we <a href=\"https://go.dev/cl/644122\">now enforce the limit as defined by the standard</a>.</p><p>The results of this audit validate the effort the Go team has put into developing high-quality, easy to use cryptography libraries and should provide confidence to our users who rely on them to build safe and secure software.</p><p>We’re not resting on our laurels, though: the Go contributors are continuing to develop and improve the cryptography libraries we provide users.</p><p>Go 1.24 now includes a FIPS 140-3 mode written in pure Go, which is currently undergoing CMVP testing. This will provide a supported FIPS 140-3 compliant mode for all users of Go, replacing the currently unsupported Go+BoringCrypto integration.</p><p>We are also working to implement modern post-quantum cryptography, introducing a ML-KEM-768 and ML-KEM-1024 implementation in Go 1.24 in the <a href=\"https://go.dev/pkg/crypto/mlkem\">crypto/mlkem package</a>, and adding support to the crypto/tls package for the hybrid X25519MLKEM768 key exchange.</p><p>Finally, we are planning on introducing new easier to use high-level cryptography APIs, designed to reduce the barrier for picking and using high-quality algorithms for basic use cases. We plan to begin with offering a simple password hashing API that removes the need for users to decide which of the myriad of possible algorithms they should be relying on, with mechanisms to automatically migrate to newer algorithms as the state-of-the-art changes.</p>","contentLength":10019,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}