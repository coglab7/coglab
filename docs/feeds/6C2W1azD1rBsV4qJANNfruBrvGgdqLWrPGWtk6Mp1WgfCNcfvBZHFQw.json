{"id":"6C2W1azD1rBsV4qJANNfruBrvGgdqLWrPGWtk6Mp1WgfCNcfvBZHFQw","title":"The System Design Newsletter","displayTitle":"Dev - System Design Newsletter","url":"https://newsletter.systemdesign.one/feed","feedLink":"https://newsletter.systemdesign.one/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":4,"items":[{"title":"How API Gateway Actually Work ‚≠ê","url":"https://newsletter.systemdesign.one/p/how-api-gateway-works","date":1748518297,"author":"Neo Kim","guid":54,"unread":true,"content":"<p>Get my system design playbook for FREE on newsletter signup:</p><p><em>This post outlines how API Gateway</em><em>works. You will find references at the bottom of this page if you want to go deeper.</em></p><p>Once upon a time, there lived a software engineering student named Maya.</p><p>She worked as a freelancer part-time.</p><p>Although she had many customers, the platform fee was extremely high.</p><p>One day, she decided to build a freelancer site with fair pricing.</p><p>And her tiny site became popular in a short time.</p><p>So she set up a microservices architecture for scalability.</p><p>Yet she didn‚Äôt know much about architectural design patterns.</p><p>And set up separate public URLs for each microservice.</p><p>The client talked directly to different microservices based on the task.</p><p>This means tight coupling and increased client complexity.</p><p>Also many users accessed her site on their mobile. </p><p>Yet she sent the same amount of information to the desktop and mobile users.</p><p>And this worsened the latency and bandwidth usage.</p><p>So she set up an API Gateway.</p><p>Imagine the  as a hotel receptionist who checks a user‚Äôs reservation and gives them room keys.</p><p>It let her move the non-business logic, such as authorization, into a separate service.</p><p>Code reviews are critical but time-consuming. CodeRabbit acts as your AI co-pilot, giving you instant code review comments and the potential impact of each pull request.</p><p>Besides, CodeRabbit provides one-click fix suggestions. It also lets you define custom code quality rules using AST Grep patterns and catch subtle issues that traditional static analysis tools might miss.</p><p>CodeRabbit has reviewed over 10 million PRs; it's installed on 1 million repositories, and 70k+ open-source projects use it. CodeRabbit is free for all open-source repos.</p><ul><li><p>Logical errors (incorrect conditions, miscalculations)</p></li><li><p>Common pitfalls (off-by-one, infinite loops)</p></li><li><p>Concurrency issues (data races, deadlocks)</p></li><li><p>Security vulnerabilities (SQL injection, XSS, CSRF)</p></li><li><p>Code smells (duplication, lengthy methods)</p></li><li><p>Best practices violations (SOLID, DRY, KISS)</p></li><li><p>Complexity issues (time &amp; space inefficiencies)</p></li><li><p>Weak error handling (especially external calls)</p></li><li><p>Maintainability &amp; readability concerns</p></li></ul><p>Writing clean, secure, and performant code is tough. CodeRabbit makes it easy.</p><p>The API Gateway acts as a single entry point for the site.</p><p>The client sends the request over <a href=\"https://www.cloudflare.com/en-gb/learning/ssl/what-is-https/\">HTTPS</a> for security.</p><p>Yet it has to be decrypted, and this takes extra processing power on each server.</p><p>So the API Gateway does . This means decrypting traffic before forwarding it to microservices, thus reducing server load.</p><p>Here‚Äôs how the API Gateway routes the request:</p><ol><li><p>The client sends the request to the API Gateway</p></li><li><p>It then checks if the client is allowed to make the request</p></li><li><p>The API Gateway validates the request‚Äôs header and body against the schema. Also transform the request if necessary</p></li><li><p>It routes the request to the correct microservices. It handles routing based on the request‚Äôs URL path, HTTP headers, method, or query parameters</p></li><li><p>The API Gateway then combines the responses from different microservices</p></li><li><p>It responds to the client and caches the response for future requests if needed</p></li></ol><p>Also it finds the device type, such as desktop or mobile, from HTTP headers to route the request accordingly. This approach simplifies the client logic and improves latency.</p><p>Besides the API Gateway prevents overloading of unhealthy servers by pausing repeated failing requests. This technique is called the .</p><p>Although the API Gateway simplifies client interactions, it introduces a set of problems.</p><ul><li><p>It increases latency as there‚Äôs an extra network hop</p></li><li><p>It increases costs and operational complexity because of maintenance efforts</p></li><li><p>It might become a performance bottleneck when there‚Äôs high traffic</p></li></ul><p>Also it could become a  if set up incorrectly. So it‚Äôs necessary to install more instances of the API Gateway for high availability.</p><p>Some popular ways to set up an API Gateway are using <a href=\"https://nginx.org/\">Nginx</a>, <a href=\"https://konghq.com/\">Kong</a>, or <a href=\"https://tyk.io/\">Tyk</a>.</p><p>A popular variant of the API Gateway is the backend for frontend () pattern. It means a separate API Gateway for each device type‚Äîdesktop and mobile.</p><p>While the API Gateway pattern offers many benefits, it‚Äôs important to use it carefully. Otherwise it‚Äôll add more complexity than value.</p><p>Subscribe to get simplified case studies delivered straight to your inbox:</p><p><strong>Want to advertise in this newsletter? </strong>üì∞</p><p>Thank you for supporting this newsletter.</p><p>You are now 150,001+ readers strong, very close to 151k. Let‚Äôs try to get 151k readers by 5 June. Consider sharing this post with your friends and get rewards.</p><p>You can find a summary of the article <a href=\"https://www.linkedin.com/posts/nk-systemdesign-one_give-me-2-minsill-teach-you-how-api-gateway-activity-7333816910720999428-mHbA\">here</a>. Consider a repost if you find it helpful.</p>","contentLength":4572,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/98649508-84dd-4f6b-872c-d2550b4cc7a5_1280x720.png","enclosureMime":"","commentsUrl":null},{"title":"System Design Playbook üî•","url":"https://newsletter.systemdesign.one/p/system-design-pdf","date":1747995248,"author":"Neo Kim","guid":53,"unread":true,"content":"<p>Once upon a time, I spent hours reading books and engineering blogs. </p><p>But I forget things fast, and because of this, I couldn't put most ideas into practice.</p><p>Until one day, I started to write notes on the main ideas. It helped me become a better engineer than my past self.</p><p>Now I have created a playbook to help you learn system design.</p><ul><li><p>Condensed notes to read for the system design interview</p></li><li><p>Key concepts to understand system design fundamentals</p></li><li><p>Important techniques from real-world engineering case studies</p></li></ul><p>You can download the playbook for FREE by joining the newsletter:</p>","contentLength":567,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/42587ee1-b3df-41f7-a42c-2f405cb07d4a_1280x720.png","enclosureMime":"","commentsUrl":null},{"title":"How Load Balancing Algorithms Really Work ‚≠ê","url":"https://newsletter.systemdesign.one/p/load-balancing-algorithms","date":1747654916,"author":"Neo Kim","guid":52,"unread":true,"content":"<p>Get my system design playbook for FREE on newsletter signup:</p><p><em>This post outlines 6 popular load balancing algorithms. You will find references at the bottom of this page if you want to go deeper.</em></p><p><em>Note: This post is based on my research and may differ from real-world implementation.</em></p><p>Once upon a time, there lived 2 QA engineers named John and Paul.</p><p>They worked for a tech company named Hooli.</p><p>Although bright, they never got promoted.</p><p>So they were sad and frustrated.</p><p>Until one day, they had a smart idea to build a photo-sharing app.</p><p>And their growth skyrocketed every day.</p><p>So they scaled by installing more servers.</p><p>But uneven traffic distribution caused server overload.</p><p>So they set up a load balancer for each service.</p><p>Think of  as a component that distributes traffic evenly among servers.</p><p>Yet each service has a different workload and usage pattern.</p><p>NHIs surged with the rise of AI agents, microservices, and distributed cloud systems. This ebook gives you a practical roadmap to secure NHIs in your architecture, with Zero Trust principles at the core:</p><ul><li><p>Real-world examples of AI and NHI specific security threats, illustrated by incidents from Okta, GitHub, and Microsoft + OWASP research</p></li><li><p>12 security principles with 35 practical steps for risk-informed NHI governance</p></li><li><p>A vendor landscape and evaluation checklist to help you build out your NHI security infrastructure</p></li></ul><h2>Load Balancing Algorithms</h2><p>Here‚Äôs how they load balance traffic across different services:</p><p>One weekend, their app became trending on the play store.</p><p>Because of this, many users tried to log in at the same time. Yet it‚Äôs necessary to distribute traffic evenly among auth servers.</p><p>So they installed the round robin algorithm on the load balancer.</p><ul><li><p>The load balancer keeps a list of servers</p></li><li><p>It then forwards requests to the servers in sequential order</p></li></ul><p>Once it reaches the end of the list, it starts again from the first server.</p><p>This approach is simple to set up and understand. Yet it doesn't consider how long a request takes, so slow requests might overload the server.</p><p>Until one day, a celebrity uploads a photo on the app. </p><p>Because of that, millions of users check their feed. Yet some servers handling the feed might be slow due to garbage collection and <a href=\"https://www.netdata.cloud/blog/understanding-linux-cpu-consumption-load-and-pressure-for-performance-optimisation/\">CPU pressure</a>.</p><p>So they use the least response time algorithm to route the requests.</p><ul><li><p>The load balancer monitors the response time of servers</p></li><li><p>It then forwards the request to the server with the fastest response time</p></li><li><p>If 2 servers have the same latency, the server with the fewest connections gets the request</p></li></ul><p>This approach has the lowest latency, yet there‚Äôs an overhead with server monitoring. Besides latency spikes might cause wrong routing decisions.</p><p>But one day, they noticed a massive spike in photo uploads.</p><p>Each photo gets processed to reduce storage costs and improve user experience. While processing some photos is complex and expensive.</p><p>So they installed the weighted round robin algorithm on the load balancer.</p><ul><li><p>The load balancer assigns a weight to each server based on its capacity</p></li><li><p>It then forwards requests based on server weight; the more the weight, the higher the requests</p></li></ul><p>Imagine  as an extension of the round robin algorithm. It means servers with higher capacity get more requests in sequential order.</p><p>This approach offers better performance. Yet scaling needs manual updates to server weights, thus increasing operational costs.</p><p>Their growth became inevitable; they added support for short videos.</p><p>A video gets transcoded into different formats for low bandwidth usage. Yet transcoding is expensive, and some videos could be lengthy.</p><p>So they installed the adaptive algorithm on the load balancer.</p><ul><li><p>An agent runs on each server, which sends the server status to the load balancer in real-time</p></li><li><p>The load balancer then routes the requests based on server metrics, such as CPU and memory usage</p></li></ul><p>Put simply, servers with lower load receive more requests. It means better fault tolerance. Yet it‚Äôs complex to set up, also the agent adds an extra overhead.</p><p>Until one day, users started to binge-watch videos on the app.</p><p>This means long-lived server connections. Yet a server can handle only a limited number of them.</p><p>So they installed the least connections algorithm on the load balancer.</p><ul><li><p>The load balancer tracks the active connections to the server</p></li><li><p>It then routes requests to the server with fewer connections</p></li></ul><p>It ensures a server doesn‚Äôt get overloaded during peak traffic. Yet tracking the number of active connections makes it complex. Also session affinity needs extra logic.</p><p>But one day, they noticed a spike in usage of their chat service.</p><p>Yet session state is necessary to track conversations in real-time.</p><p>So they installed the IP hash algorithm on the load balancer. It allows  by routing requests from a specific user to the same server.</p><ul><li><p>The load balancer uses a hash function to convert the client‚Äôs IP address into a number</p></li><li><p>It then finds the server using the number</p></li></ul><p>This approach avoids the need for an external storage for sticky sessions.</p><p>Yet there‚Äôs a risk of server overload if IP addresses aren‚Äôt random. Also many clients might share the same IP address, thus making it less effective. </p><p>There are 2 ways to set up a load balancer: a hardware load balancer or a software load balancer.</p><p>A hardware load balancer runs on a separate physical server. Although it offers high performance, it's expensive.</p><p>So they set up a software load balancer. It runs on general-purpose hardware. Besides it's easy to scale and cost-effective.</p><p>And everyone lived happily ever after.</p><p>Subscribe to get simplified case studies delivered straight to your inbox:</p><p><strong>Want to advertise in this newsletter? </strong>üì∞</p><p>Thank you for supporting this newsletter. Consider sharing this post with your friends and get rewards. Y‚Äôall are the best.</p>","contentLength":5712,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/df63a17b-ea6d-4f14-9a1f-d571bf065f4c_1280x720.png","enclosureMime":"","commentsUrl":null},{"title":"How JWT Works ‚ú®","url":"https://newsletter.systemdesign.one/p/how-jwt-works","date":1746878264,"author":"Neo Kim","guid":51,"unread":true,"content":"<p>Get my system design playbook for FREE on newsletter signup:</p><p><em>This post outlines how JSON Web Token works. You will find references at the bottom of this page if you want to go deeper.</em></p><p><em>Note: This post is based on my research and may differ from real-world implementation.</em></p><p>Once upon a time, there lived a software engineering student named Keiko.</p><p>Although extremely bright, she never worked on any real-world projects.</p><p>So she struggled with coding.</p><p>Until one day, when she decided to build a weather app.</p><p>And shared it with her friends.</p><p>Yet she had no idea how user authorization worked.</p><p>HTTP is stateless; it means each request should include the necessary information.</p><p>And her friends had to enter their username and password on each page for authorization.</p><p>So she set up a  on the server:</p><ul><li><p>It tracks user sessions and gives a session ID to the client.</p></li><li><p>And the client includes the session ID with each request header.</p></li></ul><p>The server then checks the session store to identify the client for access.</p><p>Although it temporarily solved the authorization problem, there were newer issues.</p><p>Her tiny app became popular among university students across the world.</p><p>So she had to install more servers and put them behind a load balancer.</p><p>But it became difficult to manage sessions with many servers. </p><p>Because the load balancer might route requests from a user to different servers.</p><p>So she set up . It means routing requests from a specific user to the same server using their user ID or IP address.</p><p>Yet it doesn‚Äôt scale well because of stateful servers and uneven load distribution.</p><p>So she installed a . It keeps session data separate in a central store.</p><p>A shared session store allows stateless servers. But introduces coupling and becomes a single point of failure.</p><p>So she set up JSON Web Token () for authorization.</p><p>Think of JWT as a badge to enter a building. A user gets the badge from the front desk after verification. Then they can access authorized rooms without verifying their identity again.</p><p><em>The server doesn‚Äôt store session information with JWT</em>. Instead JWT includes necessary authorization information, and the server checks the JWT on each request.</p><p>Imagine  as permission to enter a building. And  as the permission to enter specific rooms of the building.</p><p>Simple, robust, and blazingly fast.</p><p>Linear is purpose-built for engineers:</p><ul><li><p>Automate your Git workflows</p></li><li><p>Navigate your entire workflow with keyboard shortcuts</p></li></ul><p>Less grunt work, less context switching. More focus, more flow. See for yourself with $250 off.</p><p>JWT doesn‚Äôt look like a JSON object, but a set of characters. </p><ul><li><p>Header: It specifies the signing algorithm, such as RSA or HMAC</p></li><li><p>Payload: It contains data and expiry time</p></li><li><p>Signature: It shows the payload‚Äôs authenticity</p></li></ul><p>The  is <a href=\"https://base64.guru/standards/base64url\">base64url</a> encoded for compactness and ease of transmission across networks.</p><p>The server combines the header and payload with a secret key. Then it performs the signing algorithm to create the . Only the server has access to the secret key.</p><p>The server recomputes the signature using the header and payload each time it receives a JWT. Thus checking if the payload was modified.</p><p>Here‚Äôs the JWT authorization workflow:</p><ol><li><p>The user enters the name and password for authentication</p></li><li><p>The server creates a JWT using the authorization information</p></li><li><p>The server signs the JWT and gives it to the client</p></li><li><p>The client includes JWT in HTTP headers for authorization</p></li></ol><p>The server allows a request only if the signature on the JWT is valid.</p><p>There‚Äôs a risk of JWT getting stolen and used for false authorization. </p><p>Here are some ways to avoid this problem:</p><ul><li><p>Send JWT over HTTPS for security</p></li><li><p>Set an expiry time on the JWT to limit the damage</p></li><li><p>Assign minimum roles to JWT to reduce the damage</p></li></ul><p>Yet there‚Äôs no way to invalidate a stolen JWT. A workaround is to include the stolen JWT in a denial list on the server.</p><p>JWT remains a popular authorization mechanism on the internet and in microservices architecture. It makes it easier to transfer information across services.</p><p>Solving a problem makes the next one easier.</p><p>So build projects. And join my free newsletter to elevate your system design skills.</p><p>Subscribe to get simplified case studies delivered straight to your inbox:</p><p><strong>Want to advertise in this newsletter? </strong>üì∞</p><p>Thank you for supporting this newsletter. Consider sharing this post with your friends and get rewards. Y‚Äôall are the best.</p><p>You can find a summary of the article <a href=\"https://substack.com/@systemdesignone/note/c-116012013?utm_source=notes-share-action&amp;r=28q5ao\">here</a>. Consider a repost if you find it helpful.</p>","contentLength":4383,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/5b48f3f4-fdda-4da8-9eb3-288289bb9475_1280x720.png","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}